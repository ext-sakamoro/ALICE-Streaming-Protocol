// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod alice {

    #[allow(unused_imports, dead_code)]
    pub mod asp {

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PACKET_TYPE: i8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PACKET_TYPE: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PACKET_TYPE: [PacketType; 4] = [
            PacketType::IPacket,
            PacketType::DPacket,
            PacketType::CPacket,
            PacketType::SPacket,
        ];

        /// Packet type identifier
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct PacketType(pub i8);
        #[allow(non_upper_case_globals)]
        impl PacketType {
            pub const IPacket: Self = Self(1);
            pub const DPacket: Self = Self(2);
            pub const CPacket: Self = Self(3);
            pub const SPacket: Self = Self(4);

            pub const ENUM_MIN: i8 = 1;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::IPacket, Self::DPacket, Self::CPacket, Self::SPacket];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::IPacket => Some("IPacket"),
                    Self::DPacket => Some("DPacket"),
                    Self::CPacket => Some("CPacket"),
                    Self::SPacket => Some("SPacket"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for PacketType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for PacketType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for PacketType {
            type Output = PacketType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for PacketType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for PacketType {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for PacketType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PATTERN_TYPE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PATTERN_TYPE: i8 = 7;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PATTERN_TYPE: [PatternType; 8] = [
            PatternType::Solid,
            PatternType::GradientLinear,
            PatternType::GradientRadial,
            PatternType::Noise,
            PatternType::Texture,
            PatternType::Dct,
            PatternType::Periodic,
            PatternType::Complex,
        ];

        /// Pattern type for procedural generation
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct PatternType(pub i8);
        #[allow(non_upper_case_globals)]
        impl PatternType {
            pub const Solid: Self = Self(0);
            pub const GradientLinear: Self = Self(1);
            pub const GradientRadial: Self = Self(2);
            pub const Noise: Self = Self(3);
            pub const Texture: Self = Self(4);
            pub const Dct: Self = Self(5);
            pub const Periodic: Self = Self(6);
            pub const Complex: Self = Self(7);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 7;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Solid,
                Self::GradientLinear,
                Self::GradientRadial,
                Self::Noise,
                Self::Texture,
                Self::Dct,
                Self::Periodic,
                Self::Complex,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Solid => Some("Solid"),
                    Self::GradientLinear => Some("GradientLinear"),
                    Self::GradientRadial => Some("GradientRadial"),
                    Self::Noise => Some("Noise"),
                    Self::Texture => Some("Texture"),
                    Self::Dct => Some("Dct"),
                    Self::Periodic => Some("Periodic"),
                    Self::Complex => Some("Complex"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for PatternType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for PatternType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for PatternType {
            type Output = PatternType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for PatternType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for PatternType {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for PatternType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_MOTION_TYPE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_MOTION_TYPE: i8 = 5;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_MOTION_TYPE: [MotionType; 6] = [
            MotionType::None,
            MotionType::Linear,
            MotionType::Easing,
            MotionType::Oscillate,
            MotionType::Path,
            MotionType::Physics,
        ];

        /// Motion type for animation
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct MotionType(pub i8);
        #[allow(non_upper_case_globals)]
        impl MotionType {
            pub const None: Self = Self(0);
            pub const Linear: Self = Self(1);
            pub const Easing: Self = Self(2);
            pub const Oscillate: Self = Self(3);
            pub const Path: Self = Self(4);
            pub const Physics: Self = Self(5);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::None,
                Self::Linear,
                Self::Easing,
                Self::Oscillate,
                Self::Path,
                Self::Physics,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::None => Some("None"),
                    Self::Linear => Some("Linear"),
                    Self::Easing => Some("Easing"),
                    Self::Oscillate => Some("Oscillate"),
                    Self::Path => Some("Path"),
                    Self::Physics => Some("Physics"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for MotionType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for MotionType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for MotionType {
            type Output = MotionType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for MotionType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for MotionType {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for MotionType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_ROI_TYPE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_ROI_TYPE: i8 = 5;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_ROI_TYPE: [RoiType; 6] = [
            RoiType::General,
            RoiType::Face,
            RoiType::Text,
            RoiType::Edge,
            RoiType::Motion,
            RoiType::Custom,
        ];

        /// Region of Interest type
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct RoiType(pub i8);
        #[allow(non_upper_case_globals)]
        impl RoiType {
            pub const General: Self = Self(0);
            pub const Face: Self = Self(1);
            pub const Text: Self = Self(2);
            pub const Edge: Self = Self(3);
            pub const Motion: Self = Self(4);
            pub const Custom: Self = Self(5);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::General,
                Self::Face,
                Self::Text,
                Self::Edge,
                Self::Motion,
                Self::Custom,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::General => Some("General"),
                    Self::Face => Some("Face"),
                    Self::Text => Some("Text"),
                    Self::Edge => Some("Edge"),
                    Self::Motion => Some("Motion"),
                    Self::Custom => Some("Custom"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for RoiType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for RoiType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for RoiType {
            type Output = RoiType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for RoiType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for RoiType {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for RoiType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_QUALITY_LEVEL: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_QUALITY_LEVEL: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_QUALITY_LEVEL: [QualityLevel; 4] = [
            QualityLevel::Low,
            QualityLevel::Medium,
            QualityLevel::High,
            QualityLevel::Ultra,
        ];

        /// Quality level for encoding
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct QualityLevel(pub i8);
        #[allow(non_upper_case_globals)]
        impl QualityLevel {
            pub const Low: Self = Self(0);
            pub const Medium: Self = Self(1);
            pub const High: Self = Self(2);
            pub const Ultra: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Low, Self::Medium, Self::High, Self::Ultra];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Low => Some("Low"),
                    Self::Medium => Some("Medium"),
                    Self::High => Some("High"),
                    Self::Ultra => Some("Ultra"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for QualityLevel {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for QualityLevel {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for QualityLevel {
            type Output = QualityLevel;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for QualityLevel {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for QualityLevel {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for QualityLevel {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_SYNC_COMMAND: i8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_SYNC_COMMAND: i8 = 8;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_SYNC_COMMAND: [SyncCommand; 8] = [
            SyncCommand::RequestKeyframe,
            SyncCommand::Ack,
            SyncCommand::Nack,
            SyncCommand::EndOfStream,
            SyncCommand::BitrateAdjust,
            SyncCommand::QualityChange,
            SyncCommand::Ping,
            SyncCommand::Pong,
        ];

        /// Sync command type
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct SyncCommand(pub i8);
        #[allow(non_upper_case_globals)]
        impl SyncCommand {
            pub const RequestKeyframe: Self = Self(1);
            pub const Ack: Self = Self(2);
            pub const Nack: Self = Self(3);
            pub const EndOfStream: Self = Self(4);
            pub const BitrateAdjust: Self = Self(5);
            pub const QualityChange: Self = Self(6);
            pub const Ping: Self = Self(7);
            pub const Pong: Self = Self(8);

            pub const ENUM_MIN: i8 = 1;
            pub const ENUM_MAX: i8 = 8;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::RequestKeyframe,
                Self::Ack,
                Self::Nack,
                Self::EndOfStream,
                Self::BitrateAdjust,
                Self::QualityChange,
                Self::Ping,
                Self::Pong,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::RequestKeyframe => Some("RequestKeyframe"),
                    Self::Ack => Some("Ack"),
                    Self::Nack => Some("Nack"),
                    Self::EndOfStream => Some("EndOfStream"),
                    Self::BitrateAdjust => Some("BitrateAdjust"),
                    Self::QualityChange => Some("QualityChange"),
                    Self::Ping => Some("Ping"),
                    Self::Pong => Some("Pong"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for SyncCommand {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for SyncCommand {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for SyncCommand {
            type Output = SyncCommand;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for SyncCommand {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for SyncCommand {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for SyncCommand {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_COMPRESSION_FORMAT: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_COMPRESSION_FORMAT: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_COMPRESSION_FORMAT: [CompressionFormat; 5] = [
            CompressionFormat::Raw,
            CompressionFormat::Rle,
            CompressionFormat::Lz4,
            CompressionFormat::Zstd,
            CompressionFormat::DeltaRle,
        ];

        /// Compression format for pixel data
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct CompressionFormat(pub i8);
        #[allow(non_upper_case_globals)]
        impl CompressionFormat {
            pub const Raw: Self = Self(0);
            pub const Rle: Self = Self(1);
            pub const Lz4: Self = Self(2);
            pub const Zstd: Self = Self(3);
            pub const DeltaRle: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Raw, Self::Rle, Self::Lz4, Self::Zstd, Self::DeltaRle];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Raw => Some("Raw"),
                    Self::Rle => Some("Rle"),
                    Self::Lz4 => Some("Lz4"),
                    Self::Zstd => Some("Zstd"),
                    Self::DeltaRle => Some("DeltaRle"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for CompressionFormat {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for CompressionFormat {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for CompressionFormat {
            type Output = CompressionFormat;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for CompressionFormat {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for CompressionFormat {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for CompressionFormat {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_EASING_TYPE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_EASING_TYPE: i8 = 5;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_EASING_TYPE: [EasingType; 6] = [
            EasingType::Linear,
            EasingType::EaseIn,
            EasingType::EaseOut,
            EasingType::EaseInOut,
            EasingType::Bounce,
            EasingType::Elastic,
        ];

        /// Easing function type
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct EasingType(pub i8);
        #[allow(non_upper_case_globals)]
        impl EasingType {
            pub const Linear: Self = Self(0);
            pub const EaseIn: Self = Self(1);
            pub const EaseOut: Self = Self(2);
            pub const EaseInOut: Self = Self(3);
            pub const Bounce: Self = Self(4);
            pub const Elastic: Self = Self(5);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Linear,
                Self::EaseIn,
                Self::EaseOut,
                Self::EaseInOut,
                Self::Bounce,
                Self::Elastic,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Linear => Some("Linear"),
                    Self::EaseIn => Some("EaseIn"),
                    Self::EaseOut => Some("EaseOut"),
                    Self::EaseInOut => Some("EaseInOut"),
                    Self::Bounce => Some("Bounce"),
                    Self::Elastic => Some("Elastic"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for EasingType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for EasingType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for EasingType {
            type Output = EasingType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for EasingType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for EasingType {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for EasingType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_SYNC_DATA_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_SYNC_DATA_UNION: u8 = 5;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_SYNC_DATA_UNION: [SyncDataUnion; 6] = [
            SyncDataUnion::NONE,
            SyncDataUnion::SequenceData,
            SyncDataUnion::BitrateData,
            SyncDataUnion::QualityData,
            SyncDataUnion::LatencyData,
            SyncDataUnion::CustomData,
        ];

        /// Sync data variants
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct SyncDataUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl SyncDataUnion {
            pub const NONE: Self = Self(0);
            pub const SequenceData: Self = Self(1);
            pub const BitrateData: Self = Self(2);
            pub const QualityData: Self = Self(3);
            pub const LatencyData: Self = Self(4);
            pub const CustomData: Self = Self(5);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::SequenceData,
                Self::BitrateData,
                Self::QualityData,
                Self::LatencyData,
                Self::CustomData,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::SequenceData => Some("SequenceData"),
                    Self::BitrateData => Some("BitrateData"),
                    Self::QualityData => Some("QualityData"),
                    Self::LatencyData => Some("LatencyData"),
                    Self::CustomData => Some("CustomData"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for SyncDataUnion {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for SyncDataUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for SyncDataUnion {
            type Output = SyncDataUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for SyncDataUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for SyncDataUnion {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for SyncDataUnion {}
        pub struct SyncDataUnionUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_ASP_PAYLOAD_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_ASP_PAYLOAD_UNION: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_ASP_PAYLOAD_UNION: [AspPayloadUnion; 5] = [
            AspPayloadUnion::NONE,
            AspPayloadUnion::IPacketPayload,
            AspPayloadUnion::DPacketPayload,
            AspPayloadUnion::CPacketPayload,
            AspPayloadUnion::SPacketPayload,
        ];

        /// ASP Packet (unified payload container)
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct AspPayloadUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl AspPayloadUnion {
            pub const NONE: Self = Self(0);
            pub const IPacketPayload: Self = Self(1);
            pub const DPacketPayload: Self = Self(2);
            pub const CPacketPayload: Self = Self(3);
            pub const SPacketPayload: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::IPacketPayload,
                Self::DPacketPayload,
                Self::CPacketPayload,
                Self::SPacketPayload,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::IPacketPayload => Some("IPacketPayload"),
                    Self::DPacketPayload => Some("DPacketPayload"),
                    Self::CPacketPayload => Some("CPacketPayload"),
                    Self::SPacketPayload => Some("SPacketPayload"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for AspPayloadUnion {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for AspPayloadUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for AspPayloadUnion {
            type Output = AspPayloadUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for AspPayloadUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for AspPayloadUnion {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for AspPayloadUnion {}
        pub struct AspPayloadUnionUnionTableOffset {}

        /// RGB Color (3 bytes)
        // struct Color, aligned to 1
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Color(pub [u8; 3]);
        impl Default for Color {
            fn default() -> Self {
                Self([0; 3])
            }
        }
        impl ::core::fmt::Debug for Color {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("Color")
                    .field("r", &self.r())
                    .field("g", &self.g())
                    .field("b", &self.b())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for Color {}
        impl<'a> ::flatbuffers::Follow<'a> for Color {
            type Inner = &'a Color;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a Color>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a Color {
            type Inner = &'a Color;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<Color>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for Color {
            type Output = Color;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const Color as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(1)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for Color {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Color {
            #[allow(clippy::too_many_arguments)]
            pub fn new(r: u8, g: u8, b: u8) -> Self {
                let mut s = Self([0; 3]);
                s.set_r(r);
                s.set_g(g);
                s.set_b(b);
                s
            }

            pub fn r(&self) -> u8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<u8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_r(&mut self, x: u8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn g(&self) -> u8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<u8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[1..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_g(&mut self, x: u8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[1..].as_mut_ptr(),
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn b(&self) -> u8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<u8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[2..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_b(&mut self, x: u8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[2..].as_mut_ptr(),
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        /// 2D Point with integer coordinates (8 bytes)
        // struct Point, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Point(pub [u8; 8]);
        impl Default for Point {
            fn default() -> Self {
                Self([0; 8])
            }
        }
        impl ::core::fmt::Debug for Point {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("Point")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for Point {}
        impl<'a> ::flatbuffers::Follow<'a> for Point {
            type Inner = &'a Point;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a Point>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a Point {
            type Inner = &'a Point;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<Point>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for Point {
            type Output = Point;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const Point as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(4)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for Point {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Point {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: i32, y: i32) -> Self {
                let mut s = Self([0; 8]);
                s.set_x(x);
                s.set_y(y);
                s
            }

            pub fn x(&self) -> i32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <i32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<i32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: i32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<i32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> i32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <i32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<i32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: i32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        ::core::mem::size_of::<<i32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        /// Rectangle definition (16 bytes)
        // struct Rect, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rect(pub [u8; 16]);
        impl Default for Rect {
            fn default() -> Self {
                Self([0; 16])
            }
        }
        impl ::core::fmt::Debug for Rect {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("Rect")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .field("width", &self.width())
                    .field("height", &self.height())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for Rect {}
        impl<'a> ::flatbuffers::Follow<'a> for Rect {
            type Inner = &'a Rect;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a Rect>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a Rect {
            type Inner = &'a Rect;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<Rect>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for Rect {
            type Output = Rect;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const Rect as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(4)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for Rect {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Rect {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: u32, y: u32, width: u32, height: u32) -> Self {
                let mut s = Self([0; 16]);
                s.set_x(x);
                s.set_y(y);
                s.set_width(width);
                s.set_height(height);
                s
            }

            pub fn x(&self) -> u32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: u32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> u32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: u32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn width(&self) -> u32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_width(&mut self, x: u32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn height(&self) -> u32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[12..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_height(&mut self, x: u32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[12..].as_mut_ptr(),
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        /// Motion vector (12 bytes, optimized for cache)
        /// For 4K video (3840x2160), 16x16 blocks = 240x135 = 32,400 blocks
        /// uint16 range (0-65535) is sufficient for block indices.
        // struct MotionVector, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct MotionVector(pub [u8; 12]);
        impl Default for MotionVector {
            fn default() -> Self {
                Self([0; 12])
            }
        }
        impl ::core::fmt::Debug for MotionVector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("MotionVector")
                    .field("block_x", &self.block_x())
                    .field("block_y", &self.block_y())
                    .field("dx", &self.dx())
                    .field("dy", &self.dy())
                    .field("sad", &self.sad())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for MotionVector {}
        impl<'a> ::flatbuffers::Follow<'a> for MotionVector {
            type Inner = &'a MotionVector;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a MotionVector>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a MotionVector {
            type Inner = &'a MotionVector;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<MotionVector>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for MotionVector {
            type Output = MotionVector;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const MotionVector as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(4)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for MotionVector {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> MotionVector {
            #[allow(clippy::too_many_arguments)]
            pub fn new(block_x: u16, block_y: u16, dx: i16, dy: i16, sad: u32) -> Self {
                let mut s = Self([0; 12]);
                s.set_block_x(block_x);
                s.set_block_y(block_y);
                s.set_dx(dx);
                s.set_dy(dy);
                s.set_sad(sad);
                s
            }

            pub fn block_x(&self) -> u16 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u16 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_block_x(&mut self, x: u16) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn block_y(&self) -> u16 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u16 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[2..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_block_y(&mut self, x: u16) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[2..].as_mut_ptr(),
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn dx(&self) -> i16 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <i16 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<i16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_dx(&mut self, x: i16) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        ::core::mem::size_of::<<i16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn dy(&self) -> i16 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <i16 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[6..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<i16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_dy(&mut self, x: i16) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[6..].as_mut_ptr(),
                        ::core::mem::size_of::<<i16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn sad(&self) -> u32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_sad(&mut self, x: u32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        ::core::mem::size_of::<<u32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        /// Compact motion vector for bandwidth-efficient transmission (2 bytes)
        /// Block position is implicit from array index.
        /// SAD is omitted as it's only needed during encoding.
        // struct MotionVectorCompact, aligned to 1
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct MotionVectorCompact(pub [u8; 2]);
        impl Default for MotionVectorCompact {
            fn default() -> Self {
                Self([0; 2])
            }
        }
        impl ::core::fmt::Debug for MotionVectorCompact {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("MotionVectorCompact")
                    .field("dx", &self.dx())
                    .field("dy", &self.dy())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for MotionVectorCompact {}
        impl<'a> ::flatbuffers::Follow<'a> for MotionVectorCompact {
            type Inner = &'a MotionVectorCompact;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a MotionVectorCompact>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a MotionVectorCompact {
            type Inner = &'a MotionVectorCompact;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<MotionVectorCompact>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for MotionVectorCompact {
            type Output = MotionVectorCompact;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const MotionVectorCompact as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(1)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for MotionVectorCompact {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> MotionVectorCompact {
            #[allow(clippy::too_many_arguments)]
            pub fn new(dx: i8, dy: i8) -> Self {
                let mut s = Self([0; 2]);
                s.set_dx(dx);
                s.set_dy(dy);
                s
            }

            pub fn dx(&self) -> i8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<i8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<i8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_dx(&mut self, x: i8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<i8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn dy(&self) -> i8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<i8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[1..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<i8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_dy(&mut self, x: i8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[1..].as_mut_ptr(),
                        ::core::mem::size_of::<<i8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        /// DCT coefficient (sparse representation)
        // struct DctCoefficient, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct DctCoefficient(pub [u8; 8]);
        impl Default for DctCoefficient {
            fn default() -> Self {
                Self([0; 8])
            }
        }
        impl ::core::fmt::Debug for DctCoefficient {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("DctCoefficient")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .field("value", &self.value())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for DctCoefficient {}
        impl<'a> ::flatbuffers::Follow<'a> for DctCoefficient {
            type Inner = &'a DctCoefficient;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a DctCoefficient>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a DctCoefficient {
            type Inner = &'a DctCoefficient;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<DctCoefficient>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for DctCoefficient {
            type Output = DctCoefficient;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const DctCoefficient as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(4)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for DctCoefficient {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> DctCoefficient {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: u16, y: u16, value: f32) -> Self {
                let mut s = Self([0; 8]);
                s.set_x(x);
                s.set_y(y);
                s.set_value(value);
                s
            }

            pub fn x(&self) -> u16 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u16 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: u16) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> u16 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <u16 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[2..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: u16) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[2..].as_mut_ptr(),
                        ::core::mem::size_of::<<u16 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn value(&self) -> f32 {
                let mut mem = ::core::mem::MaybeUninit::<
                    <f32 as ::flatbuffers::EndianScalar>::Scalar,
                >::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<f32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_value(&mut self, x: f32) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        ::core::mem::size_of::<<f32 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        pub enum ColorPaletteOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Color palette for procedural generation
        pub struct ColorPalette<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for ColorPalette<'a> {
            type Inner = ColorPalette<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> ColorPalette<'a> {
            pub const VT_COLORS: ::flatbuffers::VOffsetT = 4;
            pub const VT_WEIGHTS: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                ColorPalette { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ColorPaletteArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<ColorPalette<'bldr>> {
                let mut builder = ColorPaletteBuilder::new(_fbb);
                if let Some(x) = args.weights {
                    builder.add_weights(x);
                }
                if let Some(x) = args.colors {
                    builder.add_colors(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn colors(&self) -> Option<::flatbuffers::Vector<'a, Color>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Color>>>(
                            ColorPalette::VT_COLORS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn weights(&self) -> Option<::flatbuffers::Vector<'a, f32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, f32>>>(
                            ColorPalette::VT_WEIGHTS,
                            None,
                        )
                }
            }
        }

        impl ::flatbuffers::Verifiable for ColorPalette<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Color>>>("colors", Self::VT_COLORS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, f32>>>("weights", Self::VT_WEIGHTS, false)?
     .finish();
                Ok(())
            }
        }
        pub struct ColorPaletteArgs<'a> {
            pub colors: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Color>>>,
            pub weights: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, f32>>>,
        }
        impl<'a> Default for ColorPaletteArgs<'a> {
            #[inline]
            fn default() -> Self {
                ColorPaletteArgs {
                    colors: None,
                    weights: None,
                }
            }
        }

        pub struct ColorPaletteBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ColorPaletteBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_colors(
                &mut self,
                colors: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, Color>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    ColorPalette::VT_COLORS,
                    colors,
                );
            }
            #[inline]
            pub fn add_weights(
                &mut self,
                weights: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, f32>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    ColorPalette::VT_WEIGHTS,
                    weights,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ColorPaletteBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ColorPaletteBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<ColorPalette<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for ColorPalette<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("ColorPalette");
                ds.field("colors", &self.colors());
                ds.field("weights", &self.weights());
                ds.finish()
            }
        }
        pub enum AnimationParamsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Animation parameters
        pub struct AnimationParams<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for AnimationParams<'a> {
            type Inner = AnimationParams<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> AnimationParams<'a> {
            pub const VT_ZOOM_FACTOR: ::flatbuffers::VOffsetT = 4;
            pub const VT_PAN_X: ::flatbuffers::VOffsetT = 6;
            pub const VT_PAN_Y: ::flatbuffers::VOffsetT = 8;
            pub const VT_ROTATION: ::flatbuffers::VOffsetT = 10;
            pub const VT_DURATION: ::flatbuffers::VOffsetT = 12;
            pub const VT_EASING: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                AnimationParams { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AnimationParamsArgs,
            ) -> ::flatbuffers::WIPOffset<AnimationParams<'bldr>> {
                let mut builder = AnimationParamsBuilder::new(_fbb);
                builder.add_duration(args.duration);
                builder.add_rotation(args.rotation);
                builder.add_pan_y(args.pan_y);
                builder.add_pan_x(args.pan_x);
                builder.add_zoom_factor(args.zoom_factor);
                builder.add_easing(args.easing);
                builder.finish()
            }

            #[inline]
            pub fn zoom_factor(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(AnimationParams::VT_ZOOM_FACTOR, Some(1.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pan_x(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(AnimationParams::VT_PAN_X, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pan_y(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(AnimationParams::VT_PAN_Y, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn rotation(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(AnimationParams::VT_ROTATION, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn duration(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(AnimationParams::VT_DURATION, Some(1))
                        .unwrap()
                }
            }
            #[inline]
            pub fn easing(&self) -> EasingType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<EasingType>(AnimationParams::VT_EASING, Some(EasingType::Linear))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for AnimationParams<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<f32>("zoom_factor", Self::VT_ZOOM_FACTOR, false)?
                    .visit_field::<f32>("pan_x", Self::VT_PAN_X, false)?
                    .visit_field::<f32>("pan_y", Self::VT_PAN_Y, false)?
                    .visit_field::<f32>("rotation", Self::VT_ROTATION, false)?
                    .visit_field::<u32>("duration", Self::VT_DURATION, false)?
                    .visit_field::<EasingType>("easing", Self::VT_EASING, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct AnimationParamsArgs {
            pub zoom_factor: f32,
            pub pan_x: f32,
            pub pan_y: f32,
            pub rotation: f32,
            pub duration: u32,
            pub easing: EasingType,
        }
        impl<'a> Default for AnimationParamsArgs {
            #[inline]
            fn default() -> Self {
                AnimationParamsArgs {
                    zoom_factor: 1.0,
                    pan_x: 0.0,
                    pan_y: 0.0,
                    rotation: 0.0,
                    duration: 1,
                    easing: EasingType::Linear,
                }
            }
        }

        pub struct AnimationParamsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> AnimationParamsBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_zoom_factor(&mut self, zoom_factor: f32) {
                self.fbb_
                    .push_slot::<f32>(AnimationParams::VT_ZOOM_FACTOR, zoom_factor, 1.0);
            }
            #[inline]
            pub fn add_pan_x(&mut self, pan_x: f32) {
                self.fbb_
                    .push_slot::<f32>(AnimationParams::VT_PAN_X, pan_x, 0.0);
            }
            #[inline]
            pub fn add_pan_y(&mut self, pan_y: f32) {
                self.fbb_
                    .push_slot::<f32>(AnimationParams::VT_PAN_Y, pan_y, 0.0);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: f32) {
                self.fbb_
                    .push_slot::<f32>(AnimationParams::VT_ROTATION, rotation, 0.0);
            }
            #[inline]
            pub fn add_duration(&mut self, duration: u32) {
                self.fbb_
                    .push_slot::<u32>(AnimationParams::VT_DURATION, duration, 1);
            }
            #[inline]
            pub fn add_easing(&mut self, easing: EasingType) {
                self.fbb_.push_slot::<EasingType>(
                    AnimationParams::VT_EASING,
                    easing,
                    EasingType::Linear,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AnimationParamsBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AnimationParamsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<AnimationParams<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for AnimationParams<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("AnimationParams");
                ds.field("zoom_factor", &self.zoom_factor());
                ds.field("pan_x", &self.pan_x());
                ds.field("pan_y", &self.pan_y());
                ds.field("rotation", &self.rotation());
                ds.field("duration", &self.duration());
                ds.field("easing", &self.easing());
                ds.finish()
            }
        }
        pub enum ParamOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Key-value parameter (for extensibility)
        pub struct Param<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Param<'a> {
            type Inner = Param<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Param<'a> {
            pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
            pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Param { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ParamArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Param<'bldr>> {
                let mut builder = ParamBuilder::new(_fbb);
                builder.add_value(args.value);
                if let Some(x) = args.key {
                    builder.add_key(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn key(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Param::VT_KEY, None)
                }
            }
            #[inline]
            pub fn value(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<f32>(Param::VT_VALUE, Some(0.0)).unwrap() }
            }
        }

        impl ::flatbuffers::Verifiable for Param<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "key",
                        Self::VT_KEY,
                        false,
                    )?
                    .visit_field::<f32>("value", Self::VT_VALUE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ParamArgs<'a> {
            pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub value: f32,
        }
        impl<'a> Default for ParamArgs<'a> {
            #[inline]
            fn default() -> Self {
                ParamArgs {
                    key: None,
                    value: 0.0,
                }
            }
        }

        pub struct ParamBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ParamBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Param::VT_KEY, key);
            }
            #[inline]
            pub fn add_value(&mut self, value: f32) {
                self.fbb_.push_slot::<f32>(Param::VT_VALUE, value, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ParamBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ParamBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Param<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Param<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Param");
                ds.field("key", &self.key());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum RegionDescriptorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Region descriptor for procedural generation
        pub struct RegionDescriptor<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for RegionDescriptor<'a> {
            type Inner = RegionDescriptor<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> RegionDescriptor<'a> {
            pub const VT_BOUNDS: ::flatbuffers::VOffsetT = 4;
            pub const VT_PATTERN_TYPE: ::flatbuffers::VOffsetT = 6;
            pub const VT_PALETTE: ::flatbuffers::VOffsetT = 8;
            pub const VT_DCT_COEFFICIENTS: ::flatbuffers::VOffsetT = 10;
            pub const VT_TEXTURE_ID: ::flatbuffers::VOffsetT = 12;
            pub const VT_PARAMS: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                RegionDescriptor { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args RegionDescriptorArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<RegionDescriptor<'bldr>> {
                let mut builder = RegionDescriptorBuilder::new(_fbb);
                if let Some(x) = args.params {
                    builder.add_params(x);
                }
                builder.add_texture_id(args.texture_id);
                if let Some(x) = args.dct_coefficients {
                    builder.add_dct_coefficients(x);
                }
                if let Some(x) = args.palette {
                    builder.add_palette(x);
                }
                if let Some(x) = args.bounds {
                    builder.add_bounds(x);
                }
                builder.add_pattern_type(args.pattern_type);
                builder.finish()
            }

            #[inline]
            pub fn bounds(&self) -> Option<&'a Rect> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Rect>(RegionDescriptor::VT_BOUNDS, None) }
            }
            #[inline]
            pub fn pattern_type(&self) -> PatternType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<PatternType>(
                            RegionDescriptor::VT_PATTERN_TYPE,
                            Some(PatternType::Solid),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn palette(&self) -> Option<ColorPalette<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<ColorPalette>>(
                            RegionDescriptor::VT_PALETTE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn dct_coefficients(&self) -> Option<::flatbuffers::Vector<'a, DctCoefficient>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, DctCoefficient>,
                    >>(RegionDescriptor::VT_DCT_COEFFICIENTS, None)
                }
            }
            #[inline]
            pub fn texture_id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(RegionDescriptor::VT_TEXTURE_ID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn params(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Param<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Param>>,
                    >>(RegionDescriptor::VT_PARAMS, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for RegionDescriptor<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_field::<Rect>("bounds", Self::VT_BOUNDS, false)?
     .visit_field::<PatternType>("pattern_type", Self::VT_PATTERN_TYPE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<ColorPalette>>("palette", Self::VT_PALETTE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, DctCoefficient>>>("dct_coefficients", Self::VT_DCT_COEFFICIENTS, false)?
     .visit_field::<u32>("texture_id", Self::VT_TEXTURE_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Param>>>>("params", Self::VT_PARAMS, false)?
     .finish();
                Ok(())
            }
        }
        pub struct RegionDescriptorArgs<'a> {
            pub bounds: Option<&'a Rect>,
            pub pattern_type: PatternType,
            pub palette: Option<::flatbuffers::WIPOffset<ColorPalette<'a>>>,
            pub dct_coefficients:
                Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, DctCoefficient>>>,
            pub texture_id: u32,
            pub params: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Param<'a>>>,
                >,
            >,
        }
        impl<'a> Default for RegionDescriptorArgs<'a> {
            #[inline]
            fn default() -> Self {
                RegionDescriptorArgs {
                    bounds: None,
                    pattern_type: PatternType::Solid,
                    palette: None,
                    dct_coefficients: None,
                    texture_id: 0,
                    params: None,
                }
            }
        }

        pub struct RegionDescriptorBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RegionDescriptorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_bounds(&mut self, bounds: &Rect) {
                self.fbb_
                    .push_slot_always::<&Rect>(RegionDescriptor::VT_BOUNDS, bounds);
            }
            #[inline]
            pub fn add_pattern_type(&mut self, pattern_type: PatternType) {
                self.fbb_.push_slot::<PatternType>(
                    RegionDescriptor::VT_PATTERN_TYPE,
                    pattern_type,
                    PatternType::Solid,
                );
            }
            #[inline]
            pub fn add_palette(&mut self, palette: ::flatbuffers::WIPOffset<ColorPalette<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<ColorPalette>>(
                        RegionDescriptor::VT_PALETTE,
                        palette,
                    );
            }
            #[inline]
            pub fn add_dct_coefficients(
                &mut self,
                dct_coefficients: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, DctCoefficient>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    RegionDescriptor::VT_DCT_COEFFICIENTS,
                    dct_coefficients,
                );
            }
            #[inline]
            pub fn add_texture_id(&mut self, texture_id: u32) {
                self.fbb_
                    .push_slot::<u32>(RegionDescriptor::VT_TEXTURE_ID, texture_id, 0);
            }
            #[inline]
            pub fn add_params(
                &mut self,
                params: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Param<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    RegionDescriptor::VT_PARAMS,
                    params,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> RegionDescriptorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                RegionDescriptorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<RegionDescriptor<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for RegionDescriptor<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("RegionDescriptor");
                ds.field("bounds", &self.bounds());
                ds.field("pattern_type", &self.pattern_type());
                ds.field("palette", &self.palette());
                ds.field("dct_coefficients", &self.dct_coefficients());
                ds.field("texture_id", &self.texture_id());
                ds.field("params", &self.params());
                ds.finish()
            }
        }
        pub enum IPacketPayloadOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// I-Packet payload: Full frame description (Keyframe)
        pub struct IPacketPayload<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for IPacketPayload<'a> {
            type Inner = IPacketPayload<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> IPacketPayload<'a> {
            pub const VT_WIDTH: ::flatbuffers::VOffsetT = 4;
            pub const VT_HEIGHT: ::flatbuffers::VOffsetT = 6;
            pub const VT_FPS: ::flatbuffers::VOffsetT = 8;
            pub const VT_QUALITY: ::flatbuffers::VOffsetT = 10;
            pub const VT_GLOBAL_PALETTE: ::flatbuffers::VOffsetT = 12;
            pub const VT_REGIONS: ::flatbuffers::VOffsetT = 14;
            pub const VT_ANIMATION: ::flatbuffers::VOffsetT = 16;
            pub const VT_TIMESTAMP_MS: ::flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                IPacketPayload { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args IPacketPayloadArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<IPacketPayload<'bldr>> {
                let mut builder = IPacketPayloadBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                if let Some(x) = args.animation {
                    builder.add_animation(x);
                }
                if let Some(x) = args.regions {
                    builder.add_regions(x);
                }
                if let Some(x) = args.global_palette {
                    builder.add_global_palette(x);
                }
                builder.add_fps(args.fps);
                builder.add_height(args.height);
                builder.add_width(args.width);
                builder.add_quality(args.quality);
                builder.finish()
            }

            #[inline]
            pub fn width(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(IPacketPayload::VT_WIDTH, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn height(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(IPacketPayload::VT_HEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fps(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(IPacketPayload::VT_FPS, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn quality(&self) -> QualityLevel {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<QualityLevel>(IPacketPayload::VT_QUALITY, Some(QualityLevel::Medium))
                        .unwrap()
                }
            }
            #[inline]
            pub fn global_palette(&self) -> Option<ColorPalette<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<ColorPalette>>(
                            IPacketPayload::VT_GLOBAL_PALETTE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn regions(
                &self,
            ) -> Option<
                ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RegionDescriptor<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RegionDescriptor>>,
                    >>(IPacketPayload::VT_REGIONS, None)
                }
            }
            #[inline]
            pub fn animation(&self) -> Option<AnimationParams<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<AnimationParams>>(
                            IPacketPayload::VT_ANIMATION,
                            None,
                        )
                }
            }
            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(IPacketPayload::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for IPacketPayload<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u32>("width", Self::VT_WIDTH, false)?
                    .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                    .visit_field::<f32>("fps", Self::VT_FPS, false)?
                    .visit_field::<QualityLevel>("quality", Self::VT_QUALITY, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<ColorPalette>>(
                        "global_palette",
                        Self::VT_GLOBAL_PALETTE,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<RegionDescriptor>>,
                    >>("regions", Self::VT_REGIONS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<AnimationParams>>(
                        "animation",
                        Self::VT_ANIMATION,
                        false,
                    )?
                    .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct IPacketPayloadArgs<'a> {
            pub width: u32,
            pub height: u32,
            pub fps: f32,
            pub quality: QualityLevel,
            pub global_palette: Option<::flatbuffers::WIPOffset<ColorPalette<'a>>>,
            pub regions: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RegionDescriptor<'a>>>,
                >,
            >,
            pub animation: Option<::flatbuffers::WIPOffset<AnimationParams<'a>>>,
            pub timestamp_ms: u64,
        }
        impl<'a> Default for IPacketPayloadArgs<'a> {
            #[inline]
            fn default() -> Self {
                IPacketPayloadArgs {
                    width: 0,
                    height: 0,
                    fps: 0.0,
                    quality: QualityLevel::Medium,
                    global_palette: None,
                    regions: None,
                    animation: None,
                    timestamp_ms: 0,
                }
            }
        }

        pub struct IPacketPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> IPacketPayloadBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_width(&mut self, width: u32) {
                self.fbb_
                    .push_slot::<u32>(IPacketPayload::VT_WIDTH, width, 0);
            }
            #[inline]
            pub fn add_height(&mut self, height: u32) {
                self.fbb_
                    .push_slot::<u32>(IPacketPayload::VT_HEIGHT, height, 0);
            }
            #[inline]
            pub fn add_fps(&mut self, fps: f32) {
                self.fbb_.push_slot::<f32>(IPacketPayload::VT_FPS, fps, 0.0);
            }
            #[inline]
            pub fn add_quality(&mut self, quality: QualityLevel) {
                self.fbb_.push_slot::<QualityLevel>(
                    IPacketPayload::VT_QUALITY,
                    quality,
                    QualityLevel::Medium,
                );
            }
            #[inline]
            pub fn add_global_palette(
                &mut self,
                global_palette: ::flatbuffers::WIPOffset<ColorPalette<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<ColorPalette>>(
                        IPacketPayload::VT_GLOBAL_PALETTE,
                        global_palette,
                    );
            }
            #[inline]
            pub fn add_regions(
                &mut self,
                regions: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<RegionDescriptor<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    IPacketPayload::VT_REGIONS,
                    regions,
                );
            }
            #[inline]
            pub fn add_animation(
                &mut self,
                animation: ::flatbuffers::WIPOffset<AnimationParams<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<AnimationParams>>(
                        IPacketPayload::VT_ANIMATION,
                        animation,
                    );
            }
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(IPacketPayload::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> IPacketPayloadBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                IPacketPayloadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<IPacketPayload<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for IPacketPayload<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("IPacketPayload");
                ds.field("width", &self.width());
                ds.field("height", &self.height());
                ds.field("fps", &self.fps());
                ds.field("quality", &self.quality());
                ds.field("global_palette", &self.global_palette());
                ds.field("regions", &self.regions());
                ds.field("animation", &self.animation());
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.finish()
            }
        }
        pub enum RegionDeltaOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Delta update for a region
        pub struct RegionDelta<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for RegionDelta<'a> {
            type Inner = RegionDelta<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> RegionDelta<'a> {
            pub const VT_REGION_INDEX: ::flatbuffers::VOffsetT = 4;
            pub const VT_PALETTE_DELTA: ::flatbuffers::VOffsetT = 6;
            pub const VT_DCT_DELTA: ::flatbuffers::VOffsetT = 8;
            pub const VT_PARAM_DELTA: ::flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                RegionDelta { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args RegionDeltaArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<RegionDelta<'bldr>> {
                let mut builder = RegionDeltaBuilder::new(_fbb);
                if let Some(x) = args.param_delta {
                    builder.add_param_delta(x);
                }
                if let Some(x) = args.dct_delta {
                    builder.add_dct_delta(x);
                }
                if let Some(x) = args.palette_delta {
                    builder.add_palette_delta(x);
                }
                builder.add_region_index(args.region_index);
                builder.finish()
            }

            #[inline]
            pub fn region_index(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(RegionDelta::VT_REGION_INDEX, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn palette_delta(&self) -> Option<ColorPalette<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<ColorPalette>>(
                            RegionDelta::VT_PALETTE_DELTA,
                            None,
                        )
                }
            }
            #[inline]
            pub fn dct_delta(&self) -> Option<::flatbuffers::Vector<'a, DctCoefficient>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, DctCoefficient>,
                    >>(RegionDelta::VT_DCT_DELTA, None)
                }
            }
            #[inline]
            pub fn param_delta(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Param<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Param>>,
                    >>(RegionDelta::VT_PARAM_DELTA, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for RegionDelta<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_field::<u32>("region_index", Self::VT_REGION_INDEX, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<ColorPalette>>("palette_delta", Self::VT_PALETTE_DELTA, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, DctCoefficient>>>("dct_delta", Self::VT_DCT_DELTA, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Param>>>>("param_delta", Self::VT_PARAM_DELTA, false)?
     .finish();
                Ok(())
            }
        }
        pub struct RegionDeltaArgs<'a> {
            pub region_index: u32,
            pub palette_delta: Option<::flatbuffers::WIPOffset<ColorPalette<'a>>>,
            pub dct_delta:
                Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, DctCoefficient>>>,
            pub param_delta: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Param<'a>>>,
                >,
            >,
        }
        impl<'a> Default for RegionDeltaArgs<'a> {
            #[inline]
            fn default() -> Self {
                RegionDeltaArgs {
                    region_index: 0,
                    palette_delta: None,
                    dct_delta: None,
                    param_delta: None,
                }
            }
        }

        pub struct RegionDeltaBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RegionDeltaBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_region_index(&mut self, region_index: u32) {
                self.fbb_
                    .push_slot::<u32>(RegionDelta::VT_REGION_INDEX, region_index, 0);
            }
            #[inline]
            pub fn add_palette_delta(
                &mut self,
                palette_delta: ::flatbuffers::WIPOffset<ColorPalette<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<ColorPalette>>(
                        RegionDelta::VT_PALETTE_DELTA,
                        palette_delta,
                    );
            }
            #[inline]
            pub fn add_dct_delta(
                &mut self,
                dct_delta: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, DctCoefficient>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    RegionDelta::VT_DCT_DELTA,
                    dct_delta,
                );
            }
            #[inline]
            pub fn add_param_delta(
                &mut self,
                param_delta: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Param<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    RegionDelta::VT_PARAM_DELTA,
                    param_delta,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> RegionDeltaBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                RegionDeltaBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<RegionDelta<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for RegionDelta<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("RegionDelta");
                ds.field("region_index", &self.region_index());
                ds.field("palette_delta", &self.palette_delta());
                ds.field("dct_delta", &self.dct_delta());
                ds.field("param_delta", &self.param_delta());
                ds.finish()
            }
        }
        pub enum DPacketPayloadOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// D-Packet payload: Delta/incremental update
        pub struct DPacketPayload<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for DPacketPayload<'a> {
            type Inner = DPacketPayload<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> DPacketPayload<'a> {
            pub const VT_REF_SEQUENCE: ::flatbuffers::VOffsetT = 4;
            pub const VT_MOTION_VECTORS: ::flatbuffers::VOffsetT = 6;
            pub const VT_MOTION_VECTORS_COMPACT: ::flatbuffers::VOffsetT = 8;
            pub const VT_GLOBAL_MOTION: ::flatbuffers::VOffsetT = 10;
            pub const VT_REGION_DELTAS: ::flatbuffers::VOffsetT = 12;
            pub const VT_TIMESTAMP_MS: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                DPacketPayload { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DPacketPayloadArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<DPacketPayload<'bldr>> {
                let mut builder = DPacketPayloadBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                if let Some(x) = args.region_deltas {
                    builder.add_region_deltas(x);
                }
                if let Some(x) = args.global_motion {
                    builder.add_global_motion(x);
                }
                if let Some(x) = args.motion_vectors_compact {
                    builder.add_motion_vectors_compact(x);
                }
                if let Some(x) = args.motion_vectors {
                    builder.add_motion_vectors(x);
                }
                builder.add_ref_sequence(args.ref_sequence);
                builder.finish()
            }

            #[inline]
            pub fn ref_sequence(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DPacketPayload::VT_REF_SEQUENCE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn motion_vectors(&self) -> Option<::flatbuffers::Vector<'a, MotionVector>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, MotionVector>>>(DPacketPayload::VT_MOTION_VECTORS, None)
                }
            }
            #[inline]
            pub fn motion_vectors_compact(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, MotionVectorCompact>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, MotionVectorCompact>,
                    >>(DPacketPayload::VT_MOTION_VECTORS_COMPACT, None)
                }
            }
            #[inline]
            pub fn global_motion(&self) -> Option<AnimationParams<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<AnimationParams>>(
                            DPacketPayload::VT_GLOBAL_MOTION,
                            None,
                        )
                }
            }
            #[inline]
            pub fn region_deltas(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RegionDelta<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RegionDelta>>,
                    >>(DPacketPayload::VT_REGION_DELTAS, None)
                }
            }
            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(DPacketPayload::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for DPacketPayload<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_field::<u32>("ref_sequence", Self::VT_REF_SEQUENCE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, MotionVector>>>("motion_vectors", Self::VT_MOTION_VECTORS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, MotionVectorCompact>>>("motion_vectors_compact", Self::VT_MOTION_VECTORS_COMPACT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<AnimationParams>>("global_motion", Self::VT_GLOBAL_MOTION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<RegionDelta>>>>("region_deltas", Self::VT_REGION_DELTAS, false)?
     .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
     .finish();
                Ok(())
            }
        }
        pub struct DPacketPayloadArgs<'a> {
            pub ref_sequence: u32,
            pub motion_vectors:
                Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, MotionVector>>>,
            pub motion_vectors_compact:
                Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, MotionVectorCompact>>>,
            pub global_motion: Option<::flatbuffers::WIPOffset<AnimationParams<'a>>>,
            pub region_deltas: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RegionDelta<'a>>>,
                >,
            >,
            pub timestamp_ms: u64,
        }
        impl<'a> Default for DPacketPayloadArgs<'a> {
            #[inline]
            fn default() -> Self {
                DPacketPayloadArgs {
                    ref_sequence: 0,
                    motion_vectors: None,
                    motion_vectors_compact: None,
                    global_motion: None,
                    region_deltas: None,
                    timestamp_ms: 0,
                }
            }
        }

        pub struct DPacketPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DPacketPayloadBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_ref_sequence(&mut self, ref_sequence: u32) {
                self.fbb_
                    .push_slot::<u32>(DPacketPayload::VT_REF_SEQUENCE, ref_sequence, 0);
            }
            #[inline]
            pub fn add_motion_vectors(
                &mut self,
                motion_vectors: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, MotionVector>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    DPacketPayload::VT_MOTION_VECTORS,
                    motion_vectors,
                );
            }
            #[inline]
            pub fn add_motion_vectors_compact(
                &mut self,
                motion_vectors_compact: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, MotionVectorCompact>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    DPacketPayload::VT_MOTION_VECTORS_COMPACT,
                    motion_vectors_compact,
                );
            }
            #[inline]
            pub fn add_global_motion(
                &mut self,
                global_motion: ::flatbuffers::WIPOffset<AnimationParams<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<AnimationParams>>(
                        DPacketPayload::VT_GLOBAL_MOTION,
                        global_motion,
                    );
            }
            #[inline]
            pub fn add_region_deltas(
                &mut self,
                region_deltas: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<RegionDelta<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    DPacketPayload::VT_REGION_DELTAS,
                    region_deltas,
                );
            }
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(DPacketPayload::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DPacketPayloadBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DPacketPayloadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<DPacketPayload<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for DPacketPayload<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("DPacketPayload");
                ds.field("ref_sequence", &self.ref_sequence());
                ds.field("motion_vectors", &self.motion_vectors());
                ds.field("motion_vectors_compact", &self.motion_vectors_compact());
                ds.field("global_motion", &self.global_motion());
                ds.field("region_deltas", &self.region_deltas());
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.finish()
            }
        }
        pub enum RoiRegionOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// ROI region for correction
        pub struct RoiRegion<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for RoiRegion<'a> {
            type Inner = RoiRegion<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> RoiRegion<'a> {
            pub const VT_BOUNDS: ::flatbuffers::VOffsetT = 4;
            pub const VT_ROI_TYPE: ::flatbuffers::VOffsetT = 6;
            pub const VT_PRIORITY: ::flatbuffers::VOffsetT = 8;
            pub const VT_CONFIDENCE: ::flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                RoiRegion { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args RoiRegionArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<RoiRegion<'bldr>> {
                let mut builder = RoiRegionBuilder::new(_fbb);
                builder.add_confidence(args.confidence);
                if let Some(x) = args.bounds {
                    builder.add_bounds(x);
                }
                builder.add_priority(args.priority);
                builder.add_roi_type(args.roi_type);
                builder.finish()
            }

            #[inline]
            pub fn bounds(&self) -> Option<&'a Rect> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Rect>(RoiRegion::VT_BOUNDS, None) }
            }
            #[inline]
            pub fn roi_type(&self) -> RoiType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<RoiType>(RoiRegion::VT_ROI_TYPE, Some(RoiType::General))
                        .unwrap()
                }
            }
            #[inline]
            pub fn priority(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(RoiRegion::VT_PRIORITY, Some(1))
                        .unwrap()
                }
            }
            #[inline]
            pub fn confidence(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(RoiRegion::VT_CONFIDENCE, Some(1.0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for RoiRegion<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<Rect>("bounds", Self::VT_BOUNDS, false)?
                    .visit_field::<RoiType>("roi_type", Self::VT_ROI_TYPE, false)?
                    .visit_field::<u8>("priority", Self::VT_PRIORITY, false)?
                    .visit_field::<f32>("confidence", Self::VT_CONFIDENCE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct RoiRegionArgs<'a> {
            pub bounds: Option<&'a Rect>,
            pub roi_type: RoiType,
            pub priority: u8,
            pub confidence: f32,
        }
        impl<'a> Default for RoiRegionArgs<'a> {
            #[inline]
            fn default() -> Self {
                RoiRegionArgs {
                    bounds: None,
                    roi_type: RoiType::General,
                    priority: 1,
                    confidence: 1.0,
                }
            }
        }

        pub struct RoiRegionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RoiRegionBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_bounds(&mut self, bounds: &Rect) {
                self.fbb_
                    .push_slot_always::<&Rect>(RoiRegion::VT_BOUNDS, bounds);
            }
            #[inline]
            pub fn add_roi_type(&mut self, roi_type: RoiType) {
                self.fbb_
                    .push_slot::<RoiType>(RoiRegion::VT_ROI_TYPE, roi_type, RoiType::General);
            }
            #[inline]
            pub fn add_priority(&mut self, priority: u8) {
                self.fbb_
                    .push_slot::<u8>(RoiRegion::VT_PRIORITY, priority, 1);
            }
            #[inline]
            pub fn add_confidence(&mut self, confidence: f32) {
                self.fbb_
                    .push_slot::<f32>(RoiRegion::VT_CONFIDENCE, confidence, 1.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> RoiRegionBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                RoiRegionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<RoiRegion<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for RoiRegion<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("RoiRegion");
                ds.field("bounds", &self.bounds());
                ds.field("roi_type", &self.roi_type());
                ds.field("priority", &self.priority());
                ds.field("confidence", &self.confidence());
                ds.finish()
            }
        }
        pub enum CorrectionDataOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Correction data for a region
        pub struct CorrectionData<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for CorrectionData<'a> {
            type Inner = CorrectionData<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CorrectionData<'a> {
            pub const VT_ROI: ::flatbuffers::VOffsetT = 4;
            pub const VT_PIXEL_DELTA: ::flatbuffers::VOffsetT = 6;
            pub const VT_COMPRESSION: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                CorrectionData { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CorrectionDataArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<CorrectionData<'bldr>> {
                let mut builder = CorrectionDataBuilder::new(_fbb);
                if let Some(x) = args.pixel_delta {
                    builder.add_pixel_delta(x);
                }
                if let Some(x) = args.roi {
                    builder.add_roi(x);
                }
                builder.add_compression(args.compression);
                builder.finish()
            }

            #[inline]
            pub fn roi(&self) -> Option<RoiRegion<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<RoiRegion>>(
                        CorrectionData::VT_ROI,
                        None,
                    )
                }
            }
            #[inline]
            pub fn pixel_delta(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(
                            CorrectionData::VT_PIXEL_DELTA,
                            None,
                        )
                }
            }
            #[inline]
            pub fn compression(&self) -> CompressionFormat {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CompressionFormat>(
                            CorrectionData::VT_COMPRESSION,
                            Some(CompressionFormat::Raw),
                        )
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for CorrectionData<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<RoiRegion>>(
                        "roi",
                        Self::VT_ROI,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>(
                        "pixel_delta",
                        Self::VT_PIXEL_DELTA,
                        false,
                    )?
                    .visit_field::<CompressionFormat>("compression", Self::VT_COMPRESSION, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CorrectionDataArgs<'a> {
            pub roi: Option<::flatbuffers::WIPOffset<RoiRegion<'a>>>,
            pub pixel_delta: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
            pub compression: CompressionFormat,
        }
        impl<'a> Default for CorrectionDataArgs<'a> {
            #[inline]
            fn default() -> Self {
                CorrectionDataArgs {
                    roi: None,
                    pixel_delta: None,
                    compression: CompressionFormat::Raw,
                }
            }
        }

        pub struct CorrectionDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CorrectionDataBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_roi(&mut self, roi: ::flatbuffers::WIPOffset<RoiRegion<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<RoiRegion>>(
                        CorrectionData::VT_ROI,
                        roi,
                    );
            }
            #[inline]
            pub fn add_pixel_delta(
                &mut self,
                pixel_delta: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    CorrectionData::VT_PIXEL_DELTA,
                    pixel_delta,
                );
            }
            #[inline]
            pub fn add_compression(&mut self, compression: CompressionFormat) {
                self.fbb_.push_slot::<CompressionFormat>(
                    CorrectionData::VT_COMPRESSION,
                    compression,
                    CompressionFormat::Raw,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CorrectionDataBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CorrectionDataBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<CorrectionData<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for CorrectionData<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("CorrectionData");
                ds.field("roi", &self.roi());
                ds.field("pixel_delta", &self.pixel_delta());
                ds.field("compression", &self.compression());
                ds.finish()
            }
        }
        pub enum CPacketPayloadOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// C-Packet payload: Correction data
        pub struct CPacketPayload<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for CPacketPayload<'a> {
            type Inner = CPacketPayload<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CPacketPayload<'a> {
            pub const VT_REF_SEQUENCE: ::flatbuffers::VOffsetT = 4;
            pub const VT_CORRECTIONS: ::flatbuffers::VOffsetT = 6;
            pub const VT_CORRECTION_COUNT: ::flatbuffers::VOffsetT = 8;
            pub const VT_TIMESTAMP_MS: ::flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                CPacketPayload { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CPacketPayloadArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<CPacketPayload<'bldr>> {
                let mut builder = CPacketPayloadBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                builder.add_correction_count(args.correction_count);
                if let Some(x) = args.corrections {
                    builder.add_corrections(x);
                }
                builder.add_ref_sequence(args.ref_sequence);
                builder.finish()
            }

            #[inline]
            pub fn ref_sequence(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(CPacketPayload::VT_REF_SEQUENCE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn corrections(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CorrectionData<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CorrectionData>>,
                    >>(CPacketPayload::VT_CORRECTIONS, None)
                }
            }
            #[inline]
            pub fn correction_count(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(CPacketPayload::VT_CORRECTION_COUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CPacketPayload::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for CPacketPayload<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u32>("ref_sequence", Self::VT_REF_SEQUENCE, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<CorrectionData>>,
                    >>("corrections", Self::VT_CORRECTIONS, false)?
                    .visit_field::<u32>("correction_count", Self::VT_CORRECTION_COUNT, false)?
                    .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CPacketPayloadArgs<'a> {
            pub ref_sequence: u32,
            pub corrections: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CorrectionData<'a>>>,
                >,
            >,
            pub correction_count: u32,
            pub timestamp_ms: u64,
        }
        impl<'a> Default for CPacketPayloadArgs<'a> {
            #[inline]
            fn default() -> Self {
                CPacketPayloadArgs {
                    ref_sequence: 0,
                    corrections: None,
                    correction_count: 0,
                    timestamp_ms: 0,
                }
            }
        }

        pub struct CPacketPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CPacketPayloadBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_ref_sequence(&mut self, ref_sequence: u32) {
                self.fbb_
                    .push_slot::<u32>(CPacketPayload::VT_REF_SEQUENCE, ref_sequence, 0);
            }
            #[inline]
            pub fn add_corrections(
                &mut self,
                corrections: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<CorrectionData<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    CPacketPayload::VT_CORRECTIONS,
                    corrections,
                );
            }
            #[inline]
            pub fn add_correction_count(&mut self, correction_count: u32) {
                self.fbb_.push_slot::<u32>(
                    CPacketPayload::VT_CORRECTION_COUNT,
                    correction_count,
                    0,
                );
            }
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(CPacketPayload::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CPacketPayloadBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CPacketPayloadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<CPacketPayload<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for CPacketPayload<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("CPacketPayload");
                ds.field("ref_sequence", &self.ref_sequence());
                ds.field("corrections", &self.corrections());
                ds.field("correction_count", &self.correction_count());
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.finish()
            }
        }
        pub enum SequenceDataOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SequenceData<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for SequenceData<'a> {
            type Inner = SequenceData<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SequenceData<'a> {
            pub const VT_SEQUENCE: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                SequenceData { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SequenceDataArgs,
            ) -> ::flatbuffers::WIPOffset<SequenceData<'bldr>> {
                let mut builder = SequenceDataBuilder::new(_fbb);
                builder.add_sequence(args.sequence);
                builder.finish()
            }

            #[inline]
            pub fn sequence(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SequenceData::VT_SEQUENCE, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for SequenceData<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u32>("sequence", Self::VT_SEQUENCE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SequenceDataArgs {
            pub sequence: u32,
        }
        impl<'a> Default for SequenceDataArgs {
            #[inline]
            fn default() -> Self {
                SequenceDataArgs { sequence: 0 }
            }
        }

        pub struct SequenceDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SequenceDataBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_sequence(&mut self, sequence: u32) {
                self.fbb_
                    .push_slot::<u32>(SequenceData::VT_SEQUENCE, sequence, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SequenceDataBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SequenceDataBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<SequenceData<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for SequenceData<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("SequenceData");
                ds.field("sequence", &self.sequence());
                ds.finish()
            }
        }
        pub enum BitrateDataOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BitrateData<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for BitrateData<'a> {
            type Inner = BitrateData<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> BitrateData<'a> {
            pub const VT_BITRATE_KBPS: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                BitrateData { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args BitrateDataArgs,
            ) -> ::flatbuffers::WIPOffset<BitrateData<'bldr>> {
                let mut builder = BitrateDataBuilder::new(_fbb);
                builder.add_bitrate_kbps(args.bitrate_kbps);
                builder.finish()
            }

            #[inline]
            pub fn bitrate_kbps(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(BitrateData::VT_BITRATE_KBPS, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for BitrateData<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u32>("bitrate_kbps", Self::VT_BITRATE_KBPS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BitrateDataArgs {
            pub bitrate_kbps: u32,
        }
        impl<'a> Default for BitrateDataArgs {
            #[inline]
            fn default() -> Self {
                BitrateDataArgs { bitrate_kbps: 0 }
            }
        }

        pub struct BitrateDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BitrateDataBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_bitrate_kbps(&mut self, bitrate_kbps: u32) {
                self.fbb_
                    .push_slot::<u32>(BitrateData::VT_BITRATE_KBPS, bitrate_kbps, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> BitrateDataBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                BitrateDataBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<BitrateData<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for BitrateData<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("BitrateData");
                ds.field("bitrate_kbps", &self.bitrate_kbps());
                ds.finish()
            }
        }
        pub enum QualityDataOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct QualityData<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for QualityData<'a> {
            type Inner = QualityData<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> QualityData<'a> {
            pub const VT_QUALITY: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                QualityData { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args QualityDataArgs,
            ) -> ::flatbuffers::WIPOffset<QualityData<'bldr>> {
                let mut builder = QualityDataBuilder::new(_fbb);
                builder.add_quality(args.quality);
                builder.finish()
            }

            #[inline]
            pub fn quality(&self) -> QualityLevel {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<QualityLevel>(QualityData::VT_QUALITY, Some(QualityLevel::Low))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for QualityData<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<QualityLevel>("quality", Self::VT_QUALITY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct QualityDataArgs {
            pub quality: QualityLevel,
        }
        impl<'a> Default for QualityDataArgs {
            #[inline]
            fn default() -> Self {
                QualityDataArgs {
                    quality: QualityLevel::Low,
                }
            }
        }

        pub struct QualityDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> QualityDataBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_quality(&mut self, quality: QualityLevel) {
                self.fbb_.push_slot::<QualityLevel>(
                    QualityData::VT_QUALITY,
                    quality,
                    QualityLevel::Low,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> QualityDataBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                QualityDataBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<QualityData<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for QualityData<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("QualityData");
                ds.field("quality", &self.quality());
                ds.finish()
            }
        }
        pub enum LatencyDataOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct LatencyData<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for LatencyData<'a> {
            type Inner = LatencyData<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> LatencyData<'a> {
            pub const VT_LATENCY_MS: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                LatencyData { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args LatencyDataArgs,
            ) -> ::flatbuffers::WIPOffset<LatencyData<'bldr>> {
                let mut builder = LatencyDataBuilder::new(_fbb);
                builder.add_latency_ms(args.latency_ms);
                builder.finish()
            }

            #[inline]
            pub fn latency_ms(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(LatencyData::VT_LATENCY_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for LatencyData<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u32>("latency_ms", Self::VT_LATENCY_MS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct LatencyDataArgs {
            pub latency_ms: u32,
        }
        impl<'a> Default for LatencyDataArgs {
            #[inline]
            fn default() -> Self {
                LatencyDataArgs { latency_ms: 0 }
            }
        }

        pub struct LatencyDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> LatencyDataBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_latency_ms(&mut self, latency_ms: u32) {
                self.fbb_
                    .push_slot::<u32>(LatencyData::VT_LATENCY_MS, latency_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> LatencyDataBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                LatencyDataBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<LatencyData<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for LatencyData<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("LatencyData");
                ds.field("latency_ms", &self.latency_ms());
                ds.finish()
            }
        }
        pub enum CustomDataOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CustomData<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for CustomData<'a> {
            type Inner = CustomData<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CustomData<'a> {
            pub const VT_DATA: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                CustomData { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CustomDataArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<CustomData<'bldr>> {
                let mut builder = CustomDataBuilder::new(_fbb);
                if let Some(x) = args.data {
                    builder.add_data(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn data(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(
                            CustomData::VT_DATA,
                            None,
                        )
                }
            }
        }

        impl ::flatbuffers::Verifiable for CustomData<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>(
                        "data",
                        Self::VT_DATA,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct CustomDataArgs<'a> {
            pub data: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for CustomDataArgs<'a> {
            #[inline]
            fn default() -> Self {
                CustomDataArgs { data: None }
            }
        }

        pub struct CustomDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CustomDataBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_data(
                &mut self,
                data: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(CustomData::VT_DATA, data);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CustomDataBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CustomDataBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<CustomData<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for CustomData<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("CustomData");
                ds.field("data", &self.data());
                ds.finish()
            }
        }
        pub enum SPacketPayloadOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// S-Packet payload: Sync/Control
        pub struct SPacketPayload<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for SPacketPayload<'a> {
            type Inner = SPacketPayload<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SPacketPayload<'a> {
            pub const VT_COMMAND: ::flatbuffers::VOffsetT = 4;
            pub const VT_DATA_TYPE: ::flatbuffers::VOffsetT = 6;
            pub const VT_DATA: ::flatbuffers::VOffsetT = 8;
            pub const VT_TIMESTAMP_MS: ::flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                SPacketPayload { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SPacketPayloadArgs,
            ) -> ::flatbuffers::WIPOffset<SPacketPayload<'bldr>> {
                let mut builder = SPacketPayloadBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                if let Some(x) = args.data {
                    builder.add_data(x);
                }
                builder.add_data_type(args.data_type);
                builder.add_command(args.command);
                builder.finish()
            }

            #[inline]
            pub fn command(&self) -> SyncCommand {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<SyncCommand>(SPacketPayload::VT_COMMAND, Some(SyncCommand::Ping))
                        .unwrap()
                }
            }
            #[inline]
            pub fn data_type(&self) -> SyncDataUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<SyncDataUnion>(
                            SPacketPayload::VT_DATA_TYPE,
                            Some(SyncDataUnion::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn data(&self) -> Option<::flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(
                            SPacketPayload::VT_DATA,
                            None,
                        )
                }
            }
            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(SPacketPayload::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn data_as_sequence_data(&self) -> Option<SequenceData<'a>> {
                if self.data_type() == SyncDataUnion::SequenceData {
                    self.data().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SequenceData::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn data_as_bitrate_data(&self) -> Option<BitrateData<'a>> {
                if self.data_type() == SyncDataUnion::BitrateData {
                    self.data().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { BitrateData::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn data_as_quality_data(&self) -> Option<QualityData<'a>> {
                if self.data_type() == SyncDataUnion::QualityData {
                    self.data().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { QualityData::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn data_as_latency_data(&self) -> Option<LatencyData<'a>> {
                if self.data_type() == SyncDataUnion::LatencyData {
                    self.data().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { LatencyData::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn data_as_custom_data(&self) -> Option<CustomData<'a>> {
                if self.data_type() == SyncDataUnion::CustomData {
                    self.data().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { CustomData::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl ::flatbuffers::Verifiable for SPacketPayload<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_field::<SyncCommand>("command", Self::VT_COMMAND, false)?
     .visit_union::<SyncDataUnion, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          SyncDataUnion::SequenceData => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<SequenceData>>("SyncDataUnion::SequenceData", pos),
          SyncDataUnion::BitrateData => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<BitrateData>>("SyncDataUnion::BitrateData", pos),
          SyncDataUnion::QualityData => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<QualityData>>("SyncDataUnion::QualityData", pos),
          SyncDataUnion::LatencyData => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<LatencyData>>("SyncDataUnion::LatencyData", pos),
          SyncDataUnion::CustomData => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<CustomData>>("SyncDataUnion::CustomData", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
     .finish();
                Ok(())
            }
        }
        pub struct SPacketPayloadArgs {
            pub command: SyncCommand,
            pub data_type: SyncDataUnion,
            pub data: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
            pub timestamp_ms: u64,
        }
        impl<'a> Default for SPacketPayloadArgs {
            #[inline]
            fn default() -> Self {
                SPacketPayloadArgs {
                    command: SyncCommand::Ping,
                    data_type: SyncDataUnion::NONE,
                    data: None,
                    timestamp_ms: 0,
                }
            }
        }

        pub struct SPacketPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SPacketPayloadBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_command(&mut self, command: SyncCommand) {
                self.fbb_.push_slot::<SyncCommand>(
                    SPacketPayload::VT_COMMAND,
                    command,
                    SyncCommand::Ping,
                );
            }
            #[inline]
            pub fn add_data_type(&mut self, data_type: SyncDataUnion) {
                self.fbb_.push_slot::<SyncDataUnion>(
                    SPacketPayload::VT_DATA_TYPE,
                    data_type,
                    SyncDataUnion::NONE,
                );
            }
            #[inline]
            pub fn add_data(
                &mut self,
                data: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(SPacketPayload::VT_DATA, data);
            }
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(SPacketPayload::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SPacketPayloadBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SPacketPayloadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<SPacketPayload<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for SPacketPayload<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("SPacketPayload");
                ds.field("command", &self.command());
                ds.field("data_type", &self.data_type());
                match self.data_type() {
                    SyncDataUnion::SequenceData => {
                        if let Some(x) = self.data_as_sequence_data() {
                            ds.field("data", &x)
                        } else {
                            ds.field(
                                "data",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    SyncDataUnion::BitrateData => {
                        if let Some(x) = self.data_as_bitrate_data() {
                            ds.field("data", &x)
                        } else {
                            ds.field(
                                "data",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    SyncDataUnion::QualityData => {
                        if let Some(x) = self.data_as_quality_data() {
                            ds.field("data", &x)
                        } else {
                            ds.field(
                                "data",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    SyncDataUnion::LatencyData => {
                        if let Some(x) = self.data_as_latency_data() {
                            ds.field("data", &x)
                        } else {
                            ds.field(
                                "data",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    SyncDataUnion::CustomData => {
                        if let Some(x) = self.data_as_custom_data() {
                            ds.field("data", &x)
                        } else {
                            ds.field(
                                "data",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("data", &x)
                    }
                };
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.finish()
            }
        }
        pub enum AspPacketPayloadOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Root packet structure
        /// Note: Header (16 bytes) is still manual-packed for maximum performance.
        /// This table contains only the payload portion.
        pub struct AspPacketPayload<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for AspPacketPayload<'a> {
            type Inner = AspPacketPayload<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> AspPacketPayload<'a> {
            pub const VT_PAYLOAD_TYPE: ::flatbuffers::VOffsetT = 4;
            pub const VT_PAYLOAD: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                AspPacketPayload { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AspPacketPayloadArgs,
            ) -> ::flatbuffers::WIPOffset<AspPacketPayload<'bldr>> {
                let mut builder = AspPacketPayloadBuilder::new(_fbb);
                if let Some(x) = args.payload {
                    builder.add_payload(x);
                }
                builder.add_payload_type(args.payload_type);
                builder.finish()
            }

            #[inline]
            pub fn payload_type(&self) -> AspPayloadUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<AspPayloadUnion>(
                            AspPacketPayload::VT_PAYLOAD_TYPE,
                            Some(AspPayloadUnion::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn payload(&self) -> Option<::flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(
                            AspPacketPayload::VT_PAYLOAD,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ipacket_payload(&self) -> Option<IPacketPayload<'a>> {
                if self.payload_type() == AspPayloadUnion::IPacketPayload {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { IPacketPayload::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_dpacket_payload(&self) -> Option<DPacketPayload<'a>> {
                if self.payload_type() == AspPayloadUnion::DPacketPayload {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { DPacketPayload::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_cpacket_payload(&self) -> Option<CPacketPayload<'a>> {
                if self.payload_type() == AspPayloadUnion::CPacketPayload {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { CPacketPayload::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_spacket_payload(&self) -> Option<SPacketPayload<'a>> {
                if self.payload_type() == AspPayloadUnion::SPacketPayload {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SPacketPayload::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl ::flatbuffers::Verifiable for AspPacketPayload<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_union::<AspPayloadUnion, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          AspPayloadUnion::IPacketPayload => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<IPacketPayload>>("AspPayloadUnion::IPacketPayload", pos),
          AspPayloadUnion::DPacketPayload => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<DPacketPayload>>("AspPayloadUnion::DPacketPayload", pos),
          AspPayloadUnion::CPacketPayload => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<CPacketPayload>>("AspPayloadUnion::CPacketPayload", pos),
          AspPayloadUnion::SPacketPayload => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<SPacketPayload>>("AspPayloadUnion::SPacketPayload", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct AspPacketPayloadArgs {
            pub payload_type: AspPayloadUnion,
            pub payload: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for AspPacketPayloadArgs {
            #[inline]
            fn default() -> Self {
                AspPacketPayloadArgs {
                    payload_type: AspPayloadUnion::NONE,
                    payload: None,
                }
            }
        }

        pub struct AspPacketPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> AspPacketPayloadBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_payload_type(&mut self, payload_type: AspPayloadUnion) {
                self.fbb_.push_slot::<AspPayloadUnion>(
                    AspPacketPayload::VT_PAYLOAD_TYPE,
                    payload_type,
                    AspPayloadUnion::NONE,
                );
            }
            #[inline]
            pub fn add_payload(
                &mut self,
                payload: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    AspPacketPayload::VT_PAYLOAD,
                    payload,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AspPacketPayloadBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AspPacketPayloadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<AspPacketPayload<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for AspPacketPayload<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("AspPacketPayload");
                ds.field("payload_type", &self.payload_type());
                match self.payload_type() {
                    AspPayloadUnion::IPacketPayload => {
                        if let Some(x) = self.payload_as_ipacket_payload() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    AspPayloadUnion::DPacketPayload => {
                        if let Some(x) = self.payload_as_dpacket_payload() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    AspPayloadUnion::CPacketPayload => {
                        if let Some(x) = self.payload_as_cpacket_payload() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    AspPayloadUnion::SPacketPayload => {
                        if let Some(x) = self.payload_as_spacket_payload() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("payload", &x)
                    }
                };
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `AspPacketPayload`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_asp_packet_payload_unchecked`.
        pub fn root_as_asp_packet_payload(
            buf: &[u8],
        ) -> Result<AspPacketPayload<'_>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::root::<AspPacketPayload>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `AspPacketPayload` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_asp_packet_payload_unchecked`.
        pub fn size_prefixed_root_as_asp_packet_payload(
            buf: &[u8],
        ) -> Result<AspPacketPayload<'_>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::size_prefixed_root::<AspPacketPayload>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `AspPacketPayload` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_asp_packet_payload_unchecked`.
        pub fn root_as_asp_packet_payload_with_opts<'b, 'o>(
            opts: &'o ::flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<AspPacketPayload<'b>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::root_with_opts::<AspPacketPayload<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `AspPacketPayload` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_asp_packet_payload_unchecked`.
        pub fn size_prefixed_root_as_asp_packet_payload_with_opts<'b, 'o>(
            opts: &'o ::flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<AspPacketPayload<'b>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::size_prefixed_root_with_opts::<AspPacketPayload<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a AspPacketPayload and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `AspPacketPayload`.
        pub unsafe fn root_as_asp_packet_payload_unchecked(buf: &[u8]) -> AspPacketPayload<'_> {
            unsafe { ::flatbuffers::root_unchecked::<AspPacketPayload>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed AspPacketPayload and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `AspPacketPayload`.
        pub unsafe fn size_prefixed_root_as_asp_packet_payload_unchecked(
            buf: &[u8],
        ) -> AspPacketPayload<'_> {
            unsafe { ::flatbuffers::size_prefixed_root_unchecked::<AspPacketPayload>(buf) }
        }
        pub const ASP_PACKET_PAYLOAD_IDENTIFIER: &str = "ASP1";

        #[inline]
        pub fn asp_packet_payload_buffer_has_identifier(buf: &[u8]) -> bool {
            ::flatbuffers::buffer_has_identifier(buf, ASP_PACKET_PAYLOAD_IDENTIFIER, false)
        }

        #[inline]
        pub fn asp_packet_payload_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
            ::flatbuffers::buffer_has_identifier(buf, ASP_PACKET_PAYLOAD_IDENTIFIER, true)
        }

        pub const ASP_PACKET_PAYLOAD_EXTENSION: &str = "asp";

        #[inline]
        pub fn finish_asp_packet_payload_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
            fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            root: ::flatbuffers::WIPOffset<AspPacketPayload<'a>>,
        ) {
            fbb.finish(root, Some(ASP_PACKET_PAYLOAD_IDENTIFIER));
        }

        #[inline]
        pub fn finish_size_prefixed_asp_packet_payload_buffer<
            'a,
            'b,
            A: ::flatbuffers::Allocator + 'a,
        >(
            fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            root: ::flatbuffers::WIPOffset<AspPacketPayload<'a>>,
        ) {
            fbb.finish_size_prefixed(root, Some(ASP_PACKET_PAYLOAD_IDENTIFIER));
        }
    } // pub mod Asp
} // pub mod Alice
